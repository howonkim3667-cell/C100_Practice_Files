#define _CRT_SECURE_NO_WARNINGS    // MSVC에서 scanf 계열 함수 사용 시 "안전 함수" 경고 비활성화
#include <stdio.h>

int main(void){
    int i, a, b, c;
    /*
    * i : 연산자/숫자 입력 등 다양한 테스트에서 재사용되는 변수
    * a : 이전 값 (좌항 피연산자)
    * b : 다음 값 (우항 피연산자)
    * c : 입력 버퍼에 남아 있는 문자(주로 '\n') 제거용
    *     getchar() 반환값을 받기 위해 int 사용 (EOF 처리 가능)
    */

    int day, month, year;   // 날짜 입력 테스트용 변수
    char s[100];            // 문자열 입력 및 버퍼 소비 테스트용 배열
    char buf[256];          // fgets로 "한 줄"을 통째로 읽어(=소비) 버퍼를 정리하기 위한 임시 버퍼

    /*
    * =============================================================================
    * [표준 입력(stdin) 버퍼 / scanf / fgets 핵심 개념 정리]
    * =============================================================================
    *
    * 1) 키보드 입력은 엔터(Enter)를 누르는 순간 한 줄 단위로 stdin 버퍼에 저장됨
    *    예) 12 + 34⏎ 를 치면 실제로는 다음 문자가 stdin에 들어감
    *        '1' '2' ' ' '+' ' ' '3' '4' '\n'
    *
    * 2) scanf / getchar는 "키보드에서 새로 입력"을 직접 받는 함수가 아니라,
    *    stdin 버퍼에 이미 들어와 있는 문자들을 포맷 규칙에 따라 순차적으로 소비(consume)하는 함수임
    *
    * 3) 입력이 '다음 입력을 기다리는(block)' 순간은 다음 조건이 동시에 만족할 때임
    *    - stdin 버퍼가 비어 있음
    *    - scanf가 포맷에 맞는 문자를 더 요구함
    *
    * 4) 버퍼에 남은 문자(특히 '\n') 때문에 다음 입력이 "바로 종료"되거나 "즉시 읽힘" 같은 현상이 발생할 수 있음
    *    - 예: "%[^\n]"는 '\n'을 소비하지 않으므로, 실행 후 stdin에 '\n'이 남기 쉬움
    *    - 예: 다음 scanf가 시작될 때 버퍼 맨 앞이 '\n'이면, 포맷에 따라 결과가 달라짐
    *
    * 5) whitespace(공백 문자) 자동 스킵 규칙 (scanf 내부 규칙)
    *    - 대부분의 변환 지정자(%d, %f, %s 등)는 "입력 시작 전" 앞쪽 공백을 자동 스킵함
    *    - 예외: %c, %[] 는 공백 자동 스킵을 하지 않음
    *
    *    => 즉, %d와 %s는 기본적으로 "앞의 공백(whitespace)"을 자동 스킵하는 성질이 있음
    *       따라서 이 scanf가 시작될 때 버퍼 맨 앞이 '\n'이라면,
    *       %d 또는 %s가 그 '\n'을 먼저 스킵하고 다음 입력/문자부터 처리하게 됨
    *       (%*d도 %d의 대입 억제 버전이므로 동일하게 앞 공백 스킵이 적용됨)
    *
    * 6) 입력 버퍼 정리(비우기)에 대한 표준적인 관점
    *    - C 표준에는 "stdin 버퍼를 비우는 전용 함수"가 없음
    *    - 보통 다음 중 하나로 버퍼의 남은 부분을 소비함
    *      (A) getchar() 반복으로 '\n' 또는 EOF까지 소비
    *      (B) fgets()로 한 줄 전체를 통째로 읽어 소비
    *
    *    특히 fgets는 한 줄을 통째로 읽어오면서 '\n'까지 같이 가져갈 수 있어,
    *    "한 줄 단위 입력"으로 통일할 때 안전하고 예측 가능함
    */

    //-----------------------------------------------------------------
    int x = scanf("%d %c %d", &a, &i, &b);
    /*
    * [1] 입력 예 : 12 + 34⏎
    *
    * scanf 동작 과정
    *  - %d : 정수 12 읽어서 a에 저장
    *  - (포맷의 공백) : 입력 버퍼의 공백 문자(공백, 개행 등) 소비
    *  - %c : 문자 '+'를 i에 저장
    *  - (포맷의 공백) : 입력 버퍼의 공백 문자 소비
    *  - %d : 정수 34 읽어서 b에 저장
    *
    * scanf 종료 후 입력 버퍼 상태
    *  - 남아 있는 문자 : '\n' (엔터)
    *
    * 반환값 x
    *  - 성공적으로 저장한 변수의 개수
    *  - %d, %c, %d → 총 3개 저장 → x = 3
    *  - 입력된 “값의 크기”와는 전혀 상관없이,
    *  - 각 변환 지정자(%d, %c, %f 등)가
    *  - “성공적으로 대입(assign)”되면 1씩 카운트해서
    *  - 그 총 개수를 int로 반환한다
    *
    * 연산자 i를 int로 선언한 이유
    *  - 문자는 내부적으로 정수(ASCII 값)
    *  - getchar / scanf 반환값과 호환
    *  - EOF 처리 및 switch 문 사용에 유리
    */

    printf("scanf의 리턴값 = %d\n", x);
    /*
    * scanf가 성공적으로 대입한 변수의 개수 출력
    * 출력 결과 : 3
    */

    printf("(1) %d %c %d\n", a, i, b);
    /*
    * 입력받은 값 확인
    * 출력 결과 : 12 + 34
    */

    c = getchar();
    /*
    * 입력 버퍼에 남아 있는 개행 문자('\n') 제거
    * - 위 scanf("%d %c %d") 수행 후 남아 있던 '\n'을 소비
    * - 이후 이어지는 입력에서 남은 '\n' 때문에 즉시 종료/실패하는 현상을 방지
    */

    /*
    * ---------------------------------------------------------------------------
    * [fgets를 이용한 버퍼(한 줄) 소비 예시]
    * ---------------------------------------------------------------------------
    *
    * 아래 코드는 "stdin에서 한 줄을 통째로 읽어서" 버퍼를 정리하는 방법임.
    * - 남은 '\n'까지 같이 읽어오기 때문에, 다음 입력을 깨끗한 상태에서 시작할 수 있음
    * - scanf와 섞어 쓰면, 어느 시점에 fgets가 '\n'만 읽어버리는 등의 혼선이 생길 수 있으니
    *   일반적으로는 입력 방식을 scanf 중심 / fgets 중심 중 하나로 통일하는 것이 안전함
    *
    * char buf[256];
    * fgets(buf, sizeof(buf), stdin);
    *
    * (의미)
    * - stdin에 남아 있는 한 줄을 buf로 읽어오고(=소비),
    * - buf를 사용하지 않으면 결과적으로 "그 줄을 버린 것"과 동일한 효과가 있음
    */

    //------------------------------------------------------
    scanf("%[0-9]", s);
    /* %[0-9]
    * [2] 입력 예 : 1234abc567⏎
    *
    *  - 숫자 0~9인 동안만 읽음
    *  - 공백 자동 스킵 없음 => 입력값 중간에 공백 있으면 중단
    *  - 조건이 깨지는 문자에서는 즉시 중단
    *  - 중단을 유발한 문자부터는 소비하지 않고 버퍼에 남음
    *
    *  입력 버퍼 상태 변화:
    *  - before : 1 2 3 4 a b c 5 6 7 \n
    *  - after  : a b c 5 6 7 \n
    *  - s에 저장된 값: "1234"
    *
    *  포인트
    *  - 이 단계에서 'a'부터는 버퍼에 남아 있으므로,
    *    다음 scanf는 별도 입력 없이도 바로 'a...'부터 읽게 됨
    */
    printf("(2) %s\n", s); // 출력 1234

    scanf("%[^\n]", s);
    /*
    * [3] 같은 입력(1234abc567⏎)에서 이어서 동작한다고 가정
    *
    * - 개행('\n')문자 전까지 읽음
    * - 개행 문자 아닌 모든 문자 버퍼에서 읽어옴
    * - 개행은 읽지 않고 버퍼에 남음
    *
    *  입력 버퍼 상태 변화:
    *   before : a b c 5 6 7 \n
    *   after  : \n
    *
    *  s에 저장된 값:
    *   "abc567"
    *
    * (설명 보강)
    *  - 여기서도 '\n'은 소비하지 않기 때문에,
    *    이 scanf 이후에도 버퍼에는 '\n'이 남아 있게 됨
    */
    printf("(3) %s\n", s); // 출력 abc567

    //----------------------------------------------
    scanf("%*d%s", &s); // 입력 123abc⏎
    /*
     * [4] %*d%s 의 동작
     *
     * 주의: 직전 단계(예: %[^\n]) 이후 버퍼에 '\n'이 남아 있을 수 있음
     * - 다만 %d와 %s는 기본적으로 "앞의 공백(whitespace)"을 자동 스킵하는 성질이 있음
     * - 따라서 이 scanf가 시작될 때 버퍼 맨 앞이 '\n'이라면,
     *   %*d(=%d 대입억제) 또는 %s가 그 '\n'을 먼저 스킵하고 다음 입력/문자부터 처리하게 됨
     *
     * %*d : 버퍼에서 숫자 부분을 읽되 변수에 저장하지 않고 버림(대입 억제)
     * %s  : 이어지는 문자열(공백 전까지)을 읽어 s에 저장
     *
     * s에 저장된 값 : "abc"
     *
     * 결과적으로:
     * - 숫자 "123"은 소비(버림)
     * - 문자열 "abc"는 s에 저장
     * - 엔터 '\n'은 이후에도 남을 수 있음(입력 종료 시점에 따라)
     */
    printf("(4) %s\n", s);

    // ---------------------------------------------------------------------------
    scanf("%d%*c%d%*c%d", &day, &month, &year); // 입력 30/08/2022⏎
    /*
    * [5] "%d%*c%d%*c%d" : 숫자 / 숫자 / 숫자 형태 처리
    * - %d  : 정수 읽기
    * - %*c : 문자 1개 읽어서 버림(대입 억제) => 여기서는 '/' 구분자 소비
    *
    * day=30, month=8, year=2022
    */
    printf("(5) %d %d %d\n", year, month, day); // 출력 2022 8 30

    scanf("%d%*s%d%*s%d%*s", &year, &month, &day); // 입력 2022년 8월 30일⏎
    /*
    * [6] "%d%*s%d%*s%d%*s" : 숫자 + 문자열(구분자) 혼합 처리
    * - %d  : 정수 읽기 (2022 / 8 / 30)
    * - %*s : 공백 전까지 문자열을 읽어 버림 ("년", "월", "일")
    *
    * 포인트
    * - %s는 앞 공백을 자동 스킵함
    * - 한글 구분자(년/월/일)와 공백이 섞인 입력을 간단히 파싱 가능
    *
    * year=2022, month=8, day=30
    */
    printf("(6) %d %d %d\n", year, month, day);

    scanf("%5d%[^\n]", &i, s);
    /*
    * [7] "%5d%[^\n]" : (의도) 새 입력 1234567⏎ 같은 것을 분해해서 읽기
    * - %5d     : 최대 5자리 정수 읽기 -> i
    * - %[^\n]  : 개행 전까지 나머지 문자열 읽기 -> s
    *
    * 포인트(핵심)
    * - scanf는 변수가 초기화돼 있는지 여부와 무관하게, stdin 버퍼만 보고 읽음
    * - 이 시점에 stdin 버퍼에 이전 입력의 잔여 데이터가 남아 있으면,
    *   새 입력을 기다리지 않고 그 잔여 데이터를 그대로 소비하여 i와 s가 결정됨
    * - 따라서 "여기서 반드시 새 입력을 받게" 만들려면,
    *   (7) 실행 직전에 stdin을 정리(예: getchar 반복, 혹은 fgets로 한 줄 소비)해야 함
    */
    printf("(7) %d\n", i);

    scanf("%5d%2d", &a, &b);
    /*
    * [8] "%5d%2d" : 숫자 덩어리를 자리수로 잘라 읽기
    * - %5d : 최대 5자리 -> a
    * - %2d : 최대 2자리 -> b
    *
    * 포인트
    * - (7)과 동일하게, stdin 버퍼에 이미 남아 있는 숫자들이 있으면
    *   새 입력 없이도 즉시 a, b를 채우고 진행함
    * - 새 입력을 의도했다면 (8) 이전에도 stdin 정리가 필요할 수 있음
    */
    printf("(8) %d %d\n", a, b);
 
    return 0;
}
