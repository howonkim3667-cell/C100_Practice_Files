#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

/*
 * =======================================================
 * [문자열과 char 배열]
 *
 * - C 언어에는 문자열(string) 전용 타입이 없다.
 * - 문자열은 항상 char 배열로 표현된다.
 *
 *   char str[] = "kang";
 *
 * - 위 문자열은 메모리에 다음과 같이 저장된다.
 *   [k][a][n][g][\0]
 *
 * - '\0' (NULL 문자)는 문자열의 끝을 의미한다.
 * - 따라서 문자열 길이보다 1바이트 더 큰 공간이 필요하다.
 *
 * =======================================================
 * [여러 개의 문자열 저장 → char 2차원 배열]
 *
 * - 이름처럼 "문자열 여러 개"를 저장하려면
 *   char 배열의 배열, 즉 char 2차원 배열을 사용한다.
 *
 *   char names[문자열개수][문자열최대길이];
 *
 * - 각 행(row)은 하나의 문자열을 의미한다.
 * - 각 열(column)은 문자(char) 하나를 의미한다.
 *
 * =======================================================
 * [문자열 리터럴과 문자 배열]
 *
 * - 문자열 리터럴 "kang" 은
 *   컴파일러가 내부적으로 다음과 같이 변환한다.
 *
 *   {'k','a','n','g','\0'}
 *
 * - 따라서 문자열 리터럴을 사용한 초기화와
 *   문자 하나씩 초기화한 방식은 본질적으로 동일하다.
 *
 * =======================================================
 * [한글과 char]
 *
 * - char 타입은 1바이트 크기이다.
 * - 한글은 UTF-8 환경에서 한 글자당 3바이트를 사용한다.
 * - 따라서 한글 한 글자는 char 하나에 저장할 수 없다.
 * - 대신 문자열(char 배열) 형태로 저장해야 한다.
 *
 * =======================================================
 */

int main(void)
{
    /* -----------------------------------------------
     * 문자열 리터럴을 사용한 2차원 char 배열
     * -----------------------------------------------
     * name1[0] : "kang"
     * name1[1] : "cho"
     * name1[2] : "kim"
     *
     * 내부 저장 형태 예:
     * name1[0] : [k][a][n][g][\0][ ][ ][ ]...[ ]
     */
    char name1[][20] = {"kang", "cho", "kim"};

    /* -----------------------------------------------
     * 문자 하나씩 초기화한 2차원 char 배열
     * (문자열 리터럴을 직접 풀어 쓴 형태)
     * name1을 컴파일러가 변환한 형태
     * ----------------------------------------------- */
    char name2[][20] = {
        {'k','a','n','g'},
        {'c','h','o'},
        {'k','i','m'}
    };

    // name1 출력 ----------------------
    for (int i = 0; i<3;i++){
        printf("%14s",name1[i]);
    }
    printf("\n");

    // name2 출력 -----------------------
    for (int i = 0; i<3;i++){
        printf("%14s",name2[i]);
    }
    printf("\n");

        /**
     * =======================================================
     * strcpy 함수 설명
     *
     * char *strcpy(char *dest, const char *src);
     *
     * - dest : 복사될 문자열이 저장될 메모리의 시작 주소
     * - src  : 원본 문자열의 시작 주소
     *
     * - 포인터를 사용하여 src가 가리키는 문자열을
     *   dest가 가리키는 메모리 공간에 직접 복사한다.
     *
     * -------------------------------------------------------
     * 주의 사항
     *
     * - strcpy는 문자열의 길이를 검사하지 않는다.
     * - dest 배열 크기보다 긴 문자열을 복사할 경우
     *   다음과 같은 문제가 발생할 수 있다.
     *
     *   · 인접한 메모리 영역 침범
     *   · 다른 변수의 값 손상
     *   · 프로그램의 예기치 않은 종료(랜덤 크래시)
     *
     * - 따라서 strcpy 사용 시 dest 배열의 크기를
     *   반드시 고려해야 한다.
     * =======================================================
     */


    /**
     * -------------------------------------------------------
     * name1 배열의 문자열 값 변경
     *
     * - name1[i]는 char 배열의 시작 주소로 해석되며
     *   strcpy의 dest 인자로 전달된다.
     *
     * - 함수 원형이 char* 형태이므로
     *   내부적으로 포인터 연산을 통해
     *   실제 메모리의 값이 변경된다.
     * -------------------------------------------------------
     */
    strcpy(name1[0], "스티브 잡스");
    strcpy(name1[1], "빌 게이츠");
    strcpy(name1[2], "데니스 리치");


    for (int i = 0; i<3;i++){
        printf("%19s",name1[i]);
    }
    printf("\n");
    
    return 0;

}
